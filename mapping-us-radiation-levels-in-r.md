Title: Mapping US Radiation Levels in R
Date: 2012-05-08 08:20
Slug: mapping-us-radiation-levels-in-r
Modified: 2014-01-07 20:35
Status: published
Category: 
Tags: zips, zip codes, coordinates, mapping, radiation, R, plotting


<div class='post'>
I have posted previously about the open data available on Socrata (https://opendata.socrata.com/), and I was looking at the site again today when I stumbled upon a listing of levels of various radioactive isotopes by US city and state. The data is available at https://opendata.socrata.com/Government/Sorted-RadNet-Laboratory-Analysis/w9fb-tgv6 . You will need to click export, and then download it as a csv. <br /> <br/> I was struck by how the data was in a very nice format for analysis. I initially wanted to look at summary statistics, but I have wanted to try some mapping for a while now, and this seemed like the right time. <!--more--> <br /> <br/> <b> Reading in the Data </b><br /><br/> To begin exploring and mapping the data, we first need to download it. After downloading, it can be read in using the read.csv command: <pre><br />rad_levels<-read.csv("Sorted_RadNet_Laboratory_Analysis.csv",<br />stringsAsFactors=FALSE,strip.white=TRUE,header=TRUE,quote="")<br /></pre> This gives us a nice data frame where each row is an observation of a different type (Drinking Water, Precipitation, etc), and the columns contain location data and data on levels of various isotopes. <br /> <br /> <b> Associating Coordinates with the Data </b><br /><br/> Unfortunately, we are not provided with any coordinates, and in order to map this data, we will need to figure out the coordinates associated with each observation. Thankfully, I recently wrote a quick function to map place names to coordinates. <pre><br />does_zip_exist<-function()<br />{<br />zip_exists<-FALSE<br />if(exists("zips"))<br />{<br /> zip_exists<-TRUE<br /> if(!nrow(zips)==43623)<br /> zip_exists<-FALSE<br />}<br />zip_exists<br />}<br /><br />get.coordinates.name<-function(city,state)<br />{<br />city<-tolower(city)<br />state<-tolower(state)<br />if(!does_zip_exist())<br /> load("zips.RData",.GlobalEnv)<br />if(nchar(state)==2)<br />{<br />zip_row<-head(zips[zips$state_abbr==state & zips$city %in% city,],1)<br />}else<br />{<br />zip_row<-head(zips[zips$state %in% state & zips$city %in% city,],1)<br />}<br />if(nrow(zip_row)==0)<br /> zip_row<-c("NA",00000,rep("NA",4),rep(0,3))<br />zip_row<br />}<br /></pre> These two functions together will enable you to get the coordinates of a given US city and state. They both depend on a file called zips.RData, which can be downloaded at http://dl.dropbox.com/u/20597506/zips.RData . The file must be present in your R working directory for the functions to work. I wrote these functions really quickly, and don't feel like rewriting them now, so please feel free to improve their performance if you want. I will make a longer post about them later if needed. <br /> <br/> Now, we have our radiation data, and the ability to associate the place names in the data to coordinates. What we need to do now is to perform that association. <pre><br />rad_level_coords<-apply(rad_levels,1,function(x) get.coordinates.name(x[2],x[1]))<br />rad_level_coords<-do.call(rbind,rad_level_coords)<br />rad_level_frame<-cbind(rad_levels,rad_level_coords)<br /></pre> This code will take each row of the radiation levels data and find the coordinates associated with the place name. It will then combine the coordinate data into a data frame, and merge it with the radiation data. <br /> <br /> <b>Cleaning up the Data</b><br /><br/> One problem at this stage is that some of the place names in the radiation data will not properly map to coordinates. The get.coordinates.name function outputs a zip code of 00000 in this case. Thus, we can remove rows that do not have proper coordinates by filtering out the rows with a zip code of 00000. <pre><br />rad_level_frame<-rad_level_frame[rad_level_frame$zip!=00000,]<br /></pre> We can also check the classes of the columns in rad_level_frame to ensure that the coordinates are numeric. <pre><br />sapply(rad_level_frame,class)<br /></pre> Unfortunately, they are not numeric columns, and they will need to be in order to use them to generate a map, so we will need to convert them: <pre><br />rad_level_frame$lat<-as.numeric(rad_level_frame$lat)<br />rad_level_frame$long<-as.numeric(rad_level_frame$long)<br /></pre> <b>Setting up the Map</b><br /><br/> We now need to do some preliminary setup before we get started on making the map. We need to define which type(s) of measurements that we want to plot, and what isotope levels that we want to plot. For this first plot, we will look at I-131 in drinking water. <pre><br />types<-c("Air Cartridge","Air Filter","Drinking Water","Precipitation","Milk")<br />current_type<-types[3]<br />target<-rad_level_frame$I.131<br /></pre> The types variable simply lists the types of measurements that are in the radiation data for convenience, and the current_type and target variables will allow us to simplify the code a bit. <br/> <br/> Since we want to plot the different levels of radiation in Drinking Water, it will help if we can bin the variable. Binning allows us to split up an interval into discrete units. In this case, binning will help us by changing the target variable into a set of colors. These colors will range from "green" (least radioactive) to red (most radioactive), and will allow us to plot the data. <pre><br />binned_target<-cut(as.numeric(target[target!="Non-detect" & <br />rad_level_frame$Sample.Type %in% current_type]), <br />breaks=5, labels=c("green","blue","yellow","orange","red"))<br /></pre> Cut is a function that will create a factor from a continuous numeric variable. Note that we have filtered out the instances of the target where nothing could be detected by removing the target variable when its value is "Non-detect". This could also be handled by changing the "Non-detect" to a zero, but as it is unclear whether "Non-detect" means a zero value, or whether it indicates equipment failure or something else, it is best to remove it entirely. We have also removed observations where the measurement type is not "Drinking Water". This will ensure that we only plot observations of drinking water radiation levels. Breaks specifies that we want to separate the data into 5 categories, which have been assigned labels according to the color that they will be plotted in. <br /> <br /> <b> Mapping the Data </b><br /><br/> Now, we are ready to create our base plot of the United States: <pre><br />plot(as.numeric(zips$long[zips$long< -60]),<br />as.numeric(zips$lat[zips$long< -60]),<br />type="p",col="gray40",pch=20,cex=0.2,xlab="",ylab="")<br /></pre> This will plot all the longitudes and latitudes from the zips.RData file in a gray color, which gives us a good US map. Specifying that the longitude be under -60 removes some of the island possessions of the US, which unnecessarily stretch out the map. The gray provides a good neutral color over which to plot our radiation levels. The pch option gives us a closed circle plotting symbol, and the cex option makes the individual points fairly small. <br /> <br /> Now, we are ready to plot our radiation levels over the base map: <pre><br />points(as.numeric(rad_level_frame$long[target!="Non-detect"&<br /> rad_level_frame$Sample.Type %in% current_type]),<br />as.numeric(rad_level_frame$lat[target!="Non-detect"& <br />rad_level_frame$Sample.Type %in% current_type]),<br />type="p",col=as.character(binned_target),pch=20,cex=1)<br /></pre> The points function adds points to a plot generated by the plot function. We have only plotted the latitudes and longitudes for the radiation level observations which are not "Non-detect", and which match our type, which is "Drinking Water". We also set the color (col) using the binned_target variable that we created earlier. The cex value is set higher so that the points appear large relative to the map. <br /> <br /> We should end up with this:<br /> <br /><b> Drinking Water Radiation Map </b> <div class="separator" style="clear: both; text-align: center;"><a href="https://vik-affirm-assets.s3-us-west-1.amazonaws.com/drinking_water.png" imageanchor="1" style="margin-left:1em; margin-right:1em"><img border="0" height="347" width="400" src="https://vik-affirm-assets.s3-us-west-1.amazonaws.com/drinking_water.png" /></a></div> We can change our current_type variable and run the plotting again to generate the rest of the plots: <b> Air Filter Radiation Map </b> <div class="separator" style="clear: both; text-align: center;"><a href="https://vik-affirm-assets.s3-us-west-1.amazonaws.com/air_filter.png" imageanchor="1" style="margin-left:1em; margin-right:1em"><img border="0" height="347" width="400" src="https://vik-affirm-assets.s3-us-west-1.amazonaws.com/air_filter.png" /></a></div> <b> Precipitation Radiation Map </b> <div class="separator" style="clear: both; text-align: center;"><a href="https://vik-affirm-assets.s3-us-west-1.amazonaws.com/precipitation.png" imageanchor="1" style="margin-left:1em; margin-right:1em"><img border="0" height="347" width="400" src="https://vik-affirm-assets.s3-us-west-1.amazonaws.com/precipitation.png" /></a></div> <b> Milk Radiation Map </b> <div class="separator" style="clear: both; text-align: center;"><a href="https://vik-affirm-assets.s3-us-west-1.amazonaws.com/milk.png" imageanchor="1" style="margin-left:1em; margin-right:1em"><img border="0" height="347" width="400" src="https://vik-affirm-assets.s3-us-west-1.amazonaws.com/milk.png" /></a></div> You can do more mapping with the other targets if you wish at this point. Here is the full code: <pre><br />setwd("~")<br />rad_levels<-read.csv("Sorted_RadNet_Laboratory_Analysis.csv",<br />stringsAsFactors=FALSE,strip.white=TRUE,header=TRUE,quote="")<br />rad_level_coords<-apply(rad_levels,1,function(x) get.coordinates.name(x[2],x[1]))<br />rad_level_coords<-do.call(rbind,rad_level_coords)<br />rad_level_frame<-cbind(rad_levels,rad_level_coords)<br /><br />rad_level_frame<-rad_level_frame[rad_level_frame$zip!=00000,]<br />rad_level_frame$lat<-as.numeric(rad_level_frame$lat)<br />rad_level_frame$long<-as.numeric(rad_level_frame$long)<br />types<-c("Air Cartridge","Air Filter","Drinking Water","Precipitation","Milk")<br />current_type<-c(types[5])<br />target<-rad_level_frame$I.131<br /><br />binned_target<-cut(as.numeric(target[target!="Non-detect" & <br />rad_level_frame$Sample.Type %in% current_type]), breaks=5,<br /> labels=c("green","blue","yellow","orange","red"))<br /><br />plot(as.numeric(zips$long[zips$long< -60]),<br />as.numeric(zips$lat[zips$long< -60]),type="p",col="gray40",<br />pch=20,cex=0.2,xlab="",ylab="")<br /><br />points(as.numeric(rad_level_frame$long[target!="Non-detect"& <br />rad_level_frame$Sample.Type %in% current_type]),<br />as.numeric(rad_level_frame$lat[target!="Non-detect"& <br />rad_level_frame$Sample.Type %in% current_type]),type="p",<br />col=as.character(binned_target),pch=20,cex=2.5)<br /></pre></div>